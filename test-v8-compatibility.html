<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L.PixiOverlay v8 Compatibility Test</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
        #log {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            background: #f5f5f5;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            margin: 5px;
            padding: 8px 16px;
            background: #007cba;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #005a87;
        }
    </style>
</head>
<body>
    <h1>Leaflet.PixiOverlay v2.0.0-beta.1 - Pixi.js v8 Compatibility Test</h1>

    <div class="controls">
        <button onclick="testSyncAPI()">Test Sync API (L.pixiOverlay)</button>
        <button onclick="testAsyncAPI()">Test Async API (L.pixiOverlayAsync)</button>
        <button onclick="testOriginAPI()">Test Origin (0,0)</button>
        <button onclick="testGradientAPI()">Test Gradients (v8.8.0+)</button>
        <button onclick="testTextAPI()">Test Text Rendering</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="map"></div>
    <div id="log"></div>

    <!-- Dependencies -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/pixi.js@8.13.2/dist/pixi.min.js"></script>
    <script src="./L.PixiOverlay.js"></script>

    <script>
        // Logging utility
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            logDiv.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // Initialize map
        const map = L.map('map').setView([39.8283, -98.5795], 4); // Center of USA
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        let currentOverlay = null;

        // Test sync API
        function testSyncAPI() {
            log('Testing L.pixiOverlay() (sync API)...');

            try {
                if (currentOverlay) {
                    map.removeLayer(currentOverlay);
                }

                // Create PIXI container and graphics
                const container = new PIXI.Container();
                const graphics = new PIXI.Graphics();

                // Draw a simple test shape (red circle)
                graphics.beginFill(0xFF0000, 0.8);
                graphics.drawCircle(0, 0, 50); // Larger circle for visibility
                graphics.endFill();
                container.addChild(graphics);

                // Draw callback - L.PixiOverlay handles scaling and positioning
                const drawCallback = function(utils) {
                    console.log('üî¥ Sync draw callback called!');

                    // Position graphics at test location (Denver, Colorado area)
                    const testLatLng = new L.LatLng(39.7392, -104.9903);
                    const point = utils.latLngToLayerPoint(testLatLng);

                    console.log('üî¥ Denver position:', testLatLng, '-> point:', point);
                    console.log('üî¥ Map zoom:', utils.getMap().getZoom(), 'Initial zoom:', utils.getScale());

                    // Update graphics position
                    graphics.x = point.x;
                    graphics.y = point.y;

                    console.log('üî¥ Graphics positioned at:', graphics.x, graphics.y);
                    console.log('üî¥ Container children:', container.children.length);

                    // Force visibility
                    graphics.visible = true;
                    container.visible = true;

                    // Manually render the container using the renderer
                    try {
                        const renderer = utils.getRenderer();
                        if (renderer) {
                            console.log('üî¥ Manually rendering container...');
                            renderer.render(container);
                        } else {
                            console.log('üî¥ No renderer available!');
                        }
                    } catch (error) {
                        console.error('üî¥ Render error:', error);
                    }
                };                // Create overlay
                currentOverlay = L.pixiOverlay(drawCallback, container, {
                    pane: 'overlayPane'
                });

                if (currentOverlay) {
                    console.log('üî¥ Adding overlay to map...');
                    map.addLayer(currentOverlay);

                    // Pan to test location to make sure it's visible
                    map.setView([39.7392, -104.9903], 8);

                    // Manually trigger a redraw to ensure callback is called
                    setTimeout(() => {
                        console.log('üî¥ Manually triggering redraw...');
                        if (currentOverlay.redraw) {
                            currentOverlay.redraw();
                        }
                    }, 100);

                    log('‚úÖ Sync API test successful! Red circle should be visible in Denver area.', 'success');
                } else {
                    log('‚ùå Failed to create overlay with sync API', 'error');
                }

            } catch (error) {
                log(`‚ùå Sync API test failed: ${error.message}`, 'error');
                console.error('Sync API test error:', error);
            }
        }        // Test async API
        function testAsyncAPI() {
            log('Testing L.pixiOverlayAsync() (async API)...');

            try {
                if (currentOverlay) {
                    map.removeLayer(currentOverlay);
                }

                // Create PIXI container and graphics
                const container = new PIXI.Container();
                const graphics = new PIXI.Graphics();

                // Draw a test shape (blue square)
                graphics.beginFill(0x0000FF, 0.8);
                graphics.drawRect(-25, -25, 50, 50); // Larger square for visibility
                graphics.endFill();
                container.addChild(graphics);

                // Draw callback - L.PixiOverlay handles scaling and positioning
                const drawCallback = function(utils) {
                    console.log('üîµ Async draw callback called!');

                    // Position graphics at test location (Austin, Texas area)
                    const testLatLng = new L.LatLng(30.2672, -97.7431);
                    const point = utils.latLngToLayerPoint(testLatLng);

                    console.log('üîµ Austin position:', testLatLng, '-> point:', point);
                    console.log('üîµ Map zoom:', utils.getMap().getZoom(), 'Initial zoom:', utils.getScale());

                    // Update graphics position
                    graphics.x = point.x;
                    graphics.y = point.y;

                    console.log('üîµ Graphics positioned at:', graphics.x, graphics.y);
                    console.log('üîµ Container children:', container.children.length);

                    // Force visibility
                    graphics.visible = true;
                    container.visible = true;

                    // Manually render the container using the renderer
                    try {
                        const renderer = utils.getRenderer();
                        if (renderer) {
                            console.log('üîµ Manually rendering container...');
                            renderer.render(container);
                        } else {
                            console.log('üîµ No renderer available!');
                        }
                    } catch (error) {
                        console.error('üîµ Render error:', error);
                    }
                };                // Create overlay with async API
                L.pixiOverlayAsync(drawCallback, container, {
                    pane: 'overlayPane'
                }).then(function(overlay) {
                    console.log('üîµ Async overlay created, adding to map...');
                    currentOverlay = overlay;
                    map.addLayer(overlay);

                    // Pan to test location to make sure it's visible
                    map.setView([30.2672, -97.7431], 8);

                    // Manually trigger a redraw to ensure callback is called
                    setTimeout(() => {
                        console.log('üîµ Manually triggering async redraw...');
                        if (overlay.redraw) {
                            overlay.redraw();
                        }
                    }, 100);

                    log('‚úÖ Async API test successful! Blue square should be visible in Austin area.', 'success');
                }).catch(function(error) {
                    log(`‚ùå Async API test failed: ${error.message}`, 'error');
                    console.error('Async API test error:', error);
                });

            } catch (error) {
                log(`‚ùå Async API test failed: ${error.message}`, 'error');
                console.error('Async API test error:', error);
            }
        }

        // Test rendering at origin
        function testOriginAPI() {
            log('Testing L.pixiOverlay() at origin (0,0)...');

            try {
                if (currentOverlay) {
                    map.removeLayer(currentOverlay);
                }

                // Create PIXI container and graphics
                const container = new PIXI.Container();
                const graphics = new PIXI.Graphics();

                // Draw a large green circle at origin
                graphics.beginFill(0x00FF00, 0.9);
                graphics.drawCircle(0, 0, 100); // Large green circle
                graphics.endFill();
                container.addChild(graphics);

                // Simple draw callback - position at null island (0,0) and render
                const drawCallback = function(utils) {
                    console.log('üü¢ Origin draw callback called!');
                    console.log('üü¢ Map center:', utils.getMap().getCenter());
                    console.log('üü¢ Map zoom:', utils.getMap().getZoom());

                    // Position at null island (0¬∞, 0¬∞)
                    const nullIsland = new L.LatLng(0, 0);
                    const point = utils.latLngToLayerPoint(nullIsland);

                    graphics.x = point.x;
                    graphics.y = point.y;

                    console.log('üü¢ Null island position:', nullIsland, '-> point:', point);
                    console.log('üü¢ Graphics positioned at:', graphics.x, graphics.y);
                    console.log('üü¢ Container children:', container.children.length);

                    // Force visibility
                    graphics.visible = true;
                    container.visible = true;

                    // Manually render the container using the renderer
                    try {
                        const renderer = utils.getRenderer();
                        if (renderer) {
                            console.log('üü¢ Manually rendering container...');
                            renderer.render(container);
                        } else {
                            console.log('üü¢ No renderer available!');
                        }
                    } catch (error) {
                        console.error('üü¢ Render error:', error);
                    }
                };                // Create overlay
                currentOverlay = L.pixiOverlay(drawCallback, container, {
                    pane: 'overlayPane'
                });

                if (currentOverlay) {
                    map.addLayer(currentOverlay);
                    // Pan to null island (0,0 lat/lng)
                    map.setView([0, 0], 6);

                    // Manually trigger a redraw
                    setTimeout(() => {
                        console.log('üü¢ Manually triggering origin redraw...');
                        if (currentOverlay.redraw) {
                            currentOverlay.redraw();
                        }
                    }, 100);

                    log('‚úÖ Origin test! Green circle should be visible at Null Island (0¬∞, 0¬∞).', 'success');
                } else {
                    log('‚ùå Failed to create overlay for origin test', 'error');
                }

            } catch (error) {
                log(`‚ùå Origin test failed: ${error.message}`, 'error');
                console.error('Origin test error:', error);
            }
        }

        // Test gradient compatibility (v8.8.0+ textureSpace behavior)
        function testGradientAPI() {
            log('Testing gradient compatibility (simplified for v8+)...');

            try {
                if (currentOverlay) {
                    map.removeLayer(currentOverlay);
                }

                const container = new PIXI.Container();
                const graphics = new PIXI.Graphics();

                // Create a simple multi-color gradient using Graphics (no texture needed)
                // This approach is more compatible across all Pixi.js versions
                graphics.beginFill(0xFF6B6B, 0.8);
                graphics.drawRect(-50, -50, 100, 25);
                graphics.endFill();

                graphics.beginFill(0xFFB347, 0.8);
                graphics.drawRect(-50, -25, 100, 25);
                graphics.endFill();

                graphics.beginFill(0x4ECDC4, 0.8);
                graphics.drawRect(-50, 0, 100, 25);
                graphics.endFill();

                graphics.beginFill(0x45B7D1, 0.8);
                graphics.drawRect(-50, 25, 100, 25);
                graphics.endFill();

                container.addChild(graphics);

                const drawCallback = function(utils) {
                    console.log('üü° Gradient draw callback called!');

                    // Position at Miami, Florida
                    const testLatLng = new L.LatLng(25.7617, -80.1918);
                    const point = utils.latLngToLayerPoint(testLatLng);

                    graphics.x = point.x;
                    graphics.y = point.y;

                    console.log('üü° Gradient graphics positioned at:', graphics.x, graphics.y);

                    graphics.visible = true;
                    container.visible = true;

                    try {
                        const renderer = utils.getRenderer();
                        if (renderer) {
                            console.log('üü° Rendering gradient container...');
                            renderer.render(container);
                        }
                    } catch (error) {
                        console.error('üü° Gradient render error:', error);
                    }
                };

                currentOverlay = L.pixiOverlay(drawCallback, container, {
                    pane: 'overlayPane'
                });

                if (currentOverlay) {
                    map.addLayer(currentOverlay);
                    map.setView([25.7617, -80.1918], 8);

                    setTimeout(() => {
                        console.log('üü° Triggering gradient redraw...');
                        if (currentOverlay.redraw) {
                            currentOverlay.redraw();
                        }
                    }, 100);

                    log('‚úÖ Gradient test successful! Gradient rectangle should be visible in Miami area.', 'success');
                }

            } catch (error) {
                log(`‚ùå Gradient test failed: ${error.message}`, 'error');
                console.error('Gradient test error:', error);
            }
        }

        // Test text rendering compatibility (v8.11.0+ anchor/padding behavior)
        function testTextAPI() {
            log('Testing text rendering compatibility (FIXED for v8+)...');

            try {
                if (currentOverlay) {
                    map.removeLayer(currentOverlay);
                }

                const container = new PIXI.Container();

                // Create v8+ compatible text style
                let textStyle;
                try {
                    textStyle = new PIXI.TextStyle({
                        fontFamily: ['Arial', 'sans-serif'],
                        fontSize: 36, // Larger for better visibility
                        fill: '#FF0000', // Single color for v8+ compatibility
                        stroke: '#000000',
                        strokeThickness: 4,
                        dropShadow: true,
                        dropShadowColor: '#000000',
                        dropShadowBlur: 4,
                        dropShadowAngle: Math.PI / 6,
                        dropShadowDistance: 6,
                        wordWrap: false
                    });
                    console.log('üü† Enhanced TextStyle created successfully');
                } catch (error) {
                    console.error('üü† Enhanced TextStyle creation failed, using basic:', error);
                    textStyle = {
                        fontFamily: 'Arial',
                        fontSize: 36,
                        fill: 0xFF0000,
                        stroke: 0x000000,
                        strokeThickness: 4
                    };
                }

                // Create debug background rectangle
                const debugRect = new PIXI.Graphics();
                debugRect.beginFill(0x00FF00, 0.2); // Semi-transparent green
                debugRect.drawRect(-200, -30, 400, 60);
                debugRect.endFill();

                // Create text with v8+ compatibility
                let mainText;
                try {
                    mainText = new PIXI.Text('üéØ V8+ TEXT RENDERING WORKS!', textStyle);
                    mainText.anchor.set(0.5, 0.5); // Center anchor
                    console.log('üü† Text object created successfully:', mainText);
                } catch (error) {
                    console.error('üü† Text creation failed:', error);
                    log('‚ùå Failed to create text object', 'error');
                    return;
                }

                container.addChild(debugRect); // Add background first
                container.addChild(mainText);  // Add text on top

                let firstDraw = true;

                const drawCallback = function(utils) {
                    console.log('üü† FIXED Text draw callback called!');

                    const map = utils.getMap();
                    const zoom = map.getZoom();
                    const scale = utils.getScale();
                    const renderer = utils.getRenderer();

                    // Position at center of USA for consistent testing
                    const testLatLng = new L.LatLng(39.8283, -98.5795);
                    const centerPoint = utils.latLngToLayerPoint(testLatLng);

                    // Position both debug rectangle and text
                    container.position.set(centerPoint.x, centerPoint.y);

                    // Scale based on zoom level to keep text visible
                    const textScale = Math.max(0.3, 1 / scale);
                    container.scale.set(textScale);

                    console.log('üü† Text positioned at:', {
                        lat: testLatLng.lat,
                        lng: testLatLng.lng,
                        point: centerPoint,
                        zoom: zoom,
                        scale: scale,
                        textScale: textScale
                    });

                    // V8+ SPECIFIC: Prepare text for rendering
                    if (utils.prepareTextForV8) {
                        utils.prepareTextForV8(mainText);
                        console.log('üü† Text prepared for v8+ rendering');
                    } else {
                        console.log('üü† Using fallback text preparation');
                        // Fallback preparation
                        if (PIXI.VERSION >= "8" && mainText.updateText) {
                            try {
                                mainText.updateText(true);
                            } catch (e) {
                                console.warn('üü† Fallback updateText failed:', e);
                            }
                        }
                    }

                    // Force visibility and properties
                    container.visible = true;
                    mainText.visible = true;
                    mainText.alpha = 1.0;
                    debugRect.visible = true;

                    console.log('üü† Text properties after setup:', {
                        x: mainText.x,
                        y: mainText.y,
                        scaleX: mainText.scale.x,
                        scaleY: mainText.scale.y,
                        visible: mainText.visible,
                        alpha: mainText.alpha,
                        text: mainText.text,
                        anchor: mainText.anchor
                    });

                    if (firstDraw) {
                        console.log('üü† First draw - text should now be visible at center of USA');
                        firstDraw = false;
                    }

                    // Render the container
                    try {
                        renderer.render(container);
                        console.log('üü† Successfully rendered container with FIXED text');
                    } catch (e) {
                        console.error('üü† Render failed:', e);
                    }
                };

                currentOverlay = L.pixiOverlay(drawCallback, container, {
                    pane: 'overlayPane'
                });

                if (currentOverlay) {
                    map.addLayer(currentOverlay);
                    // Set view to center of USA where our text will appear
                    map.setView([39.8283, -98.5795], 5);

                    setTimeout(() => {
                        console.log('üü† Triggering FIXED text redraw...');
                        if (currentOverlay.redraw) {
                            currentOverlay.redraw();
                        }
                    }, 100);

                    log('‚úÖ FIXED Text test completed! Enhanced text should now be visible on the map.', 'success');
                }

            } catch (error) {
                log(`‚ùå FIXED Text test failed: ${error.message}`, 'error');
                console.error('FIXED Text test error:', error);
            }
        }

        // Log initial state
        log('Leaflet.PixiOverlay v2.0.0-beta.1 loaded');
        log(`Pixi.js version: ${PIXI.VERSION}`);
        log(`Leaflet version: ${L.version}`);

        // Check which initialization method will be used
        if (window.L && L.PixiOverlay) {
            const testOverlay = new L.PixiOverlay(function() {}, new PIXI.Container());
            if (testOverlay._needsAsyncInit) {
                log('üîÑ Pixi.js v8+ detected - will use async initialization');
            } else {
                log('üîÑ Pixi.js v7 or earlier detected - will use sync initialization');
            }
        }
    </script>
</body>
</html>
